---
layout: post
title: stm32 base usage
date: 2020-08-24
Author: jianping
categories: 
tags: [hardware]
comments: false
---

# Contents
{:.no_toc}
* Will be replaced with the ToC, excluding the "Contents" header
{:toc}



## GPIO Write

cubeMX automatic generate initialization function of GPIo, then we use HAL_GPIO_WritePin

```cpp

HAL_GPIO_WritePin(GPIOF,LED0_Pin,GPIO_PIN_SET);

```

## GPIO Read

use HAL_GPIO_WritePin 

```cpp

GPIO_PinState pin_state = HAL_GPIO_ReadPin(GPIOE,KEY0_Pin);

```

## NVIC of GPIO

set priority of NVIC in cubeMX, then write weak funcuion: HAL_GPIO_EXTI_Callback

```cpp

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if(GPIO_Pin == GPIO_PIN_3)
	{
		if(KEY1_SET == 0 ){
			//...
		}else{
			//...
		}
	}
}

```

## General TIM (TIM 2-5)

clock source of TIM2-5 is APB1, 84MHz
![](https://pic.downk.cc/item/5f430f03160a154a67bc1ec8.jpg)

if we want to set TIM2 to 1Hz, then

|APB1:|clock source|84,000,000|
|PSC:|/(84-1)|1,000,000|
|COUNTER:|/(1,000,000-1)|1|

## Accurate delay using TIM

__HAL_TIM_SetCounter

__HAL_TIM_GetCounter

HAL_TIM_Base_Start

## NVIC of TIM

config NVIC of TIM2 in cubemx, rewrite weak function, for example: HAL_TIM_PeriodElapsedCallback

```cpp

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  if(htim->Instance == TIM2)
	{
		//...
	}
}

```

do not forget to use HAL_TIM_Base_Start_IT, which stats the NVIC

```cpp

    HAL_TIM_Base_Start_IT(&htim2); 

```

## UART

```cpp

    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xffff);
```


## UART with DMA

reference: https://blog.csdn.net/u014470361/article/details/79206352

###Transmit

```cpp
    HAL_UART_Transmit_DMA(&huart1,tx_buffer,BUFFER_SIZE);
```

###Receive

first enable uart idle interupt
```cpp
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);//idel
	__HAL_UART_CLEAR_IDLEFLAG(&huart1);
```

then rewrite the USART1_IRQHandler

```cpp
    void USART1_IRQHandler(void)
    {
      /* USER CODE BEGIN USART1_IRQn 0 */
    	
    	uint32_t tmp_flag = 0;
    	uint32_t temp;
    	tmp_flag =__HAL_UART_GET_FLAG(&huart1,UART_FLAG_IDLE); 
    	if((tmp_flag != RESET))
    	{ 
    		__HAL_UART_CLEAR_IDLEFLAG(&huart1);
    		temp = huart1.Instance->SR;  
    		temp = huart1.Instance->DR; 
    		HAL_UART_DMAStop(&huart1); //
    		temp  = hdma_usart1_rx.Instance->NDTR;//
    		int rx_len =  BUFFER_SIZE - temp; //
    		//recv_end_flag = 1;	//	
    		memcpy(my_tx_buffer,my_rx_buffer,BUFFER_SIZE);
    		HAL_UART_Transmit_DMA(&huart1,my_tx_buffer,rx_len);
    		HAL_UART_Receive_DMA(&huart1,my_rx_buffer,BUFFER_SIZE);
    	 }
    
      /* USER CODE END USART1_IRQn 0 */
      HAL_UART_IRQHandler(&huart1);
      /* USER CODE BEGIN USART1_IRQn 1 */
    
      /* USER CODE END USART1_IRQn 1 */
    }
```