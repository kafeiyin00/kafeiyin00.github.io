---
layout: post
title: 学会使用FIFO减少低速设备对cpu的占用
date: 2020-06-11
Author: jianping
categories: 
tags: [FPGA, hardware]
comments: false
---

一般来说,cpu对外设的处理都采用中断模式.但是一些低速外设,例如uart,最好不要让cpu在中断中等待太久,否则无法处理别的消息,造成假死状态.这个时候,可以使用fifo先把大量数据存储下来,等合适的时候再发出中断让cpu过来处理.有点类似快递箱对快递员的作用.总不能来一个快递,快递员就来处理下.最好还是让快递先放在快递箱里,等快递箱满了(或者别的条件),再一次性处理.

首先配置fifo, 配置为native,存储类型为:common clock block ram (读写是同步的时钟控制).

standard fifo, 位宽和深度根据需求,例如(8 , 1024).

其他信号接口根据需求选配就行. 调用方式如下:



```verilog


```


```verilog

\\\ fifo.v

module fifo(
        clk, // 时钟
        rst_n, // 低电平复位
        din, // 数据输入
        wr_en, // 使能输入
        rd_en, // 使能读取
        dout,  // 数据输出
        full,
        wr_ack,
        empty,
        valid,
        data_count
    );
    
    input           wire            clk;
    input           wire            rst_n;
    input           wire            [7:0]din;
    input           wire            wr_en;
    input           wire            rd_en;
    output          wire            [7:0]dout;
    output          wire            full;
    output          wire            wr_ack;
    output          wire            empty;
    output          wire            valid;
    output          wire            [9:0]data_count;
    
    
    
    fifo_generator_ip fifo_generator_ip_inst(
        .clk(clk),
        .srst(~rst_n), // 注意这里是高电平复位,要取反
        .din(din),
        .wr_en(wr_en),
        .rd_en(rd_en),
        .dout(dout),
        .full(full),
        .wr_ack(wr_ack),
        .empty(empty),
        .valid(valid),
        .data_count(data_count)
    );

    
endmodule

```

对上述模块进行简单的仿真

```verilog

module fifo_tb();
    reg             Clk;
    reg             Rst_n;
    
    reg             [7:0]Din;
    reg             Wr_en;
    reg             Rd_en;
    wire            [7:0]Dout;
    wire            Full;
    wire            Wr_ack;
    wire            Empty;
    wire            Valid;

    
    reg             [8:0]timecnt;
    
    wire            [9:0]data_count;
    
    
    fifo fifo_inst(
            .clk(Clk),
            .rst_n(Rst_n),
            .din(Din),
            .wr_en(Wr_en),
            .rd_en(Rd_en),
            .dout(Dout),
            .full(Full),
            .wr_ack(Wr_ack),
            .empty(Empty),
            .valid(Valid),
            .data_count(data_count)
        );
        
    always @ (posedge Clk)
    begin
        if(!Rst_n)
            timecnt <= 0;
        else 
        begin
            if(timecnt > 8'd69)
            begin
                timecnt <= 0;
            end
            else
            begin
                timecnt <= timecnt + 1;
                Din <= timecnt;
            end
        end
    end
    
    always @ (posedge Clk)
    begin
    if(!Rst_n)
        begin
        Wr_en<=0;
        Rd_en<=0;
        Din <= 8'd0;
        end
    else
        begin
        Wr_en <= ( timecnt>= 5 && timecnt<= 20 )?1'b1:1'b0;
        Rd_en <= ( timecnt>= 30 && timecnt<= 45 )?1'b1:1'b0;
        end
    end
    
    
    initial
    begin
                Clk = 0;
                Rst_n = 1;
                #10;
                Rst_n = 0;
                #10;
                Rst_n = 1;
                #10;
                #200000;
                $stop;
    end
    
    always
    begin
                #5;
                Clk = ~Clk;
    end
    
    
endmodule


```

时序图如下:

![](https://pic.downk.cc/item/5ee20e60c2a9a83be5a1070e.jpg)

*注意* standard fifo 模式下Wr_en拉高后,经过一个时钟周期后,才开始写入.

*注意* standard fifo 模式下Wr_en拉低后,经过一个时钟周期后,才停止写入.

*注意* 复位后,要等待四个时钟周期,否则写不进去.

*注意* standard fifo 模式下Rd_en拉高后,经过一个时钟周期后,才开始读入.

*注意* standard fifo 模式下Rd_en拉低后,经过一个时钟周期后,才停止读入.
