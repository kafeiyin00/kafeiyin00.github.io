---
layout: post
title: 学会使用FIFO减少低速设备对cpu的占用
date: 2020-06-11
Author: jianping
categories: 
tags: [FPGA, hardware]
comments: false
---

# 1. 前言

一般来说,cpu对外设的处理都采用中断模式.但是一些低速外设,例如uart,最好不要让cpu在中断中等待太久,否则无法处理别的消息,造成假死状态.这个时候,可以使用fifo先把大量数据存储下来,等合适的时候再发出中断让cpu过来处理.有点类似快递箱对快递员的作用.总不能来一个快递,快递员就来处理下.最好还是让快递先放在快递箱里,等快递箱满了(或者别的条件),再一次性处理. 


# 2. FIFO调用与仿真

首先配置fifo, 配置为native,存储类型为:common clock block ram (读写是同步的时钟控制).

standard fifo, 位宽和深度根据需求,例如(8 , 1024). 我猜gnss消息最长估计也就800多吧...

其他信号接口根据需求选配就行. 调用方式如下:



```verilog

/// fifo.v

module fifo(
        clk, // 时钟
        rst_n, // 低电平复位
        din, // 数据输入
        wr_en, // 使能输入
        rd_en, // 使能读取
        dout,  // 数据输出
        full,
        wr_ack,
        empty,
        valid,
        data_count
    );
    
    input           wire            clk;
    input           wire            rst_n;
    input           wire            [7:0]din;
    input           wire            wr_en;
    input           wire            rd_en;
    output          wire            [7:0]dout;
    output          wire            full;
    output          wire            wr_ack;
    output          wire            empty;
    output          wire            valid;
    output          wire            [9:0]data_count;
    
    
    
    fifo_generator_ip fifo_generator_ip_inst(
        .clk(clk),
        .srst(~rst_n), // 注意这里是高电平复位,要取反
        .din(din),
        .wr_en(wr_en),
        .rd_en(rd_en),
        .dout(dout),
        .full(full),
        .wr_ack(wr_ack),
        .empty(empty),
        .valid(valid),
        .data_count(data_count)
    );

    
endmodule

```

对上述模块进行简单的仿真

```verilog

/// fifo_tb.v

module fifo_tb();
    reg             Clk;
    reg             Rst_n;
    
    reg             [7:0]Din;
    reg             Wr_en;
    reg             Rd_en;
    wire            [7:0]Dout;
    wire            Full;
    wire            Wr_ack;
    wire            Empty;
    wire            Valid;

    
    reg             [8:0]timecnt;
    
    wire            [9:0]data_count;
    
    
    fifo fifo_inst(
            .clk(Clk),
            .rst_n(Rst_n),
            .din(Din),
            .wr_en(Wr_en),
            .rd_en(Rd_en),
            .dout(Dout),
            .full(Full),
            .wr_ack(Wr_ack),
            .empty(Empty),
            .valid(Valid),
            .data_count(data_count)
        );
        
    always @ (posedge Clk)
    begin
        if(!Rst_n)
            timecnt <= 0;
        else 
        begin
            if(timecnt > 8'd69)
            begin
                timecnt <= 0;
            end
            else
            begin
                timecnt <= timecnt + 1;
                Din <= timecnt;
            end
        end
    end
    
    always @ (posedge Clk)
    begin
    if(!Rst_n)
        begin
        Wr_en<=0;
        Rd_en<=0;
        Din <= 8'd0;
        end
    else
        begin
        Wr_en <= ( timecnt>= 5 && timecnt<= 20 )?1'b1:1'b0;
        Rd_en <= ( timecnt>= 30 && timecnt<= 45 )?1'b1:1'b0;
        end
    end
    
    
    initial
    begin
                Clk = 0;
                Rst_n = 1;
                #10;
                Rst_n = 0;
                #10;
                Rst_n = 1;
                #10;
                #200000;
                $stop;
    end
    
    always
    begin
                #5;
                Clk = ~Clk;
    end
    
    
endmodule


```

时序图如下:

![](https://pic.downk.cc/item/5ee20e60c2a9a83be5a1070e.jpg)

*注意* standard fifo 模式下Wr_en拉高后,经过一个时钟周期后,才开始写入.

*注意* standard fifo 模式下Wr_en拉低后,经过一个时钟周期后,才停止写入.

*注意* 复位后,要等待四个时钟周期,否则写不进去.

*注意* standard fifo 模式下Rd_en拉高后,经过一个时钟周期后,才开始读入.

*注意* standard fifo 模式下Rd_en拉低后,经过一个时钟周期后,才停止读入.


# 3. uart RX_port with FIFO

这里记录一个uart 的rx 端口 配合 FIFO的用法.


```verilog

/// uart_counters.v

module uart_counters(
    // Inputs
	clk,
	rst_n,
	
	reset_counters,

	// Bidirectionals

	// Outputs
	baud_clock_rising_edge,
	baud_clock_falling_edge,
	all_bits_transmitted
    );
    /*****************************************************************************
     *                           Parameter Declarations                          *
     *****************************************************************************/
    
    parameter CW                            = 10;        // BAUD COUNTER WIDTH
    parameter BAUD_TICK_COUNT               = 433;      // (1_000_000_000 / baud_rate / clk_time) - 1
    parameter HALF_BAUD_TICK_COUNT          = 216;
    
    parameter TDW                           = 10;        // TOTAL DATA WIDTH 1 + CW + 1
    
    /*****************************************************************************
     *                             Port Declarations                             *
     *****************************************************************************/
    
    input           wire            clk;
    input           wire            rst_n;
    input           wire            reset_counters;
    
    output          reg             baud_clock_rising_edge;
    output          reg             baud_clock_falling_edge;
    output          reg             all_bits_transmitted;
    
    
    // Internal Wires
    
    // Internal Registers
                    reg             [(CW-1):0]baud_counter;
                    reg             [ 3: 0]bit_counter;
    
    // State Machine Registers
    
    /*****************************************************************************
     *                             Sequential Logic                              *
     *****************************************************************************/
    
    // 波特率内部计数器
    always @(posedge clk)
    begin
        if (!rst_n)
            baud_counter <= {CW{1'b0}};
        else if (reset_counters)
            baud_counter <= {CW{1'b0}};
        else if (baud_counter == BAUD_TICK_COUNT)
            baud_counter <= {CW{1'b0}};
        else
            baud_counter <= baud_counter + 1;
    end
    
    //  baud_clock_rising_edge： 在计数到 baudcont 拉高，用于写数据 serial_out
    always @(posedge clk)
    begin
        if (!rst_n)
            baud_clock_rising_edge <= 1'b0;
        else if (baud_counter == BAUD_TICK_COUNT)
            baud_clock_rising_edge <= 1'b1;
        else
            baud_clock_rising_edge <= 1'b0;
    end
    
    // baud_clock_falling_edge： 在计数到 baudcont/2 拉高，用于读数据 serial_in
    always @(posedge clk)
    begin
        if (!rst_n)
            baud_clock_falling_edge <= 1'b0;
        else if (baud_counter == HALF_BAUD_TICK_COUNT)
            baud_clock_falling_edge <= 1'b1;
        else
            baud_clock_falling_edge <= 1'b0;
    end
    
    // bit_counter: 记录当前发送了几个bit
    always @(posedge clk)
    begin
        if (!rst_n)
            bit_counter <= 4'h0;
        else if (reset_counters)
            bit_counter <= 4'h0;
        else if (bit_counter == TDW)
            bit_counter <= 4'h0;
        else if (baud_counter == BAUD_TICK_COUNT)
            bit_counter <= bit_counter + 4'h1;
    end
    
    // all_bits_transmitted: 当完成一个byte数据传输的时候， 拉高all_bits_transmitted
    always @(posedge clk)
    begin
        if (!rst_n)
            all_bits_transmitted <= 1'b0;
        else if (bit_counter == TDW)
            all_bits_transmitted <= 1'b1;
        else
            all_bits_transmitted <= 1'b0;
    end
endmodule



```

```verilog

/// uart_in_deserializer.v

module uart_in_deserializer(
    // Inputs
	clk,
	rst_n,
	
	serial_data_in,

	receive_data_en,

	// Bidirectionals

	// Outputs
	fifo_read_available,

	received_data_valid,
	received_data
    );
    /*****************************************************************************
     *                           Parameter Declarations                          *
     *****************************************************************************/
    
    parameter CW                                = 10;        // Baud counter width
    parameter BAUD_TICK_COUNT                   = 433;
    parameter HALF_BAUD_TICK_COUNT              = 216;
    
    parameter TDW                               = 10;        // Total data width
    parameter DW                                = 8;         // Data width
    
    parameter FIFOD                             = 10;        // FIFO depth
    
    /*****************************************************************************
     *                             Port Declarations                             *
     *****************************************************************************/
    // Inputs
    input           wire                        clk;
    input           wire                        rst_n;
    
    input           wire                        serial_data_in;
    
    input           wire                        receive_data_en;
    
    // Bidirectionals
    
    // Outputs
    output          reg                         [FIFOD: 0]fifo_read_available;
    
    output          wire                        received_data_valid; // 表明fifo中有数据
    output          wire                        [DW: 0]received_data;
    
    // Internal Wires
                    wire                        shift_data_reg_en; // 允许读取一个bit，这个连接到counter上，在一个 baudcounter 中间拉高
                    wire                        all_bits_received; // 标注接收完一个byte的数据
    
                    wire                        fifo_is_empty;
                    wire                        fifo_is_full;
                    wire                        [(FIFOD)-1: 0]fifo_used;
    
    // Internal Registers
                    reg                         receiving_data; // 标注正在接收一个byte内的数据
    
                    reg                         [(TDW-1):0]data_in_shift_reg;
    
    
                    reg                          serial_data_in_0;
                    reg                          serial_data_in_1;//防止亚稳态

    /*****************************************************************************
     *                             Sequential Logic                              *
     *****************************************************************************/
     
     // fifo_read_available : 当前已经使用的fifo大小，第一位拼接一个是否满了fifo_is_full
     always @(posedge clk)
     begin
         if (!rst_n)
             fifo_read_available <= {(FIFOD+1){1'b0}};
         else
             fifo_read_available <= {fifo_is_full, fifo_used};
     end
     
     // 注意防止亚稳态
     always @(posedge clk)
     begin
        if (!rst_n)
        begin
            serial_data_in_0 <= 1;
            serial_data_in_1 <= 1;
        end
        else
        begin
            serial_data_in_0 <= serial_data_in;
            serial_data_in_1 <= serial_data_in_0;
        end
     end
     
     // receiving_data： 标注正在接受数据（一个byte内），利用检测起始位为0，拉高；利用 all_bits_received 拉低。
     always @(posedge clk)
     begin
         if (!rst_n)
             receiving_data <= 1'b0;
         else
         begin
             if (all_bits_received)
                 receiving_data <= 1'b0;
             else if (serial_data_in_1 == 1'b0)
                 receiving_data <= 1'b1;
         end
     end
     
     //  data_in_shift_reg: 接收数据
     always @(posedge clk)
     begin
         if (!rst_n)
             data_in_shift_reg    <= {TDW{1'b0}};
         else if (shift_data_reg_en)
             data_in_shift_reg    <= 
                 {serial_data_in_1, data_in_shift_reg[(TDW - 1):1]};
     end
     
     /*****************************************************************************
      *                            Combinational Logic                            *
      *****************************************************************************/
     
     // Output assignments
     assign received_data_valid = ~fifo_is_empty;
     
     // Input assignments
     
     /*****************************************************************************
      *                              Internal Modules                             *
      *****************************************************************************/
     
     uart_counters uart_in_counter_inst (
         // Inputs
         .clk(clk),
         .rst_n(rst_n),
         
         .reset_counters(~receiving_data), // 利用 receiving_data 重置内部计数器
     
         // Bidirectionals
     
         // Outputs
         .baud_clock_rising_edge(),
         .baud_clock_falling_edge(shift_data_reg_en),// 利用内部计时器驱动shift_data_reg_en拉高，去读取数据
         .all_bits_transmitted(all_bits_received) // 接收完一个byte，拉高all_bits_received
     );
     defparam 
         uart_in_counter_inst.CW                              = CW,
         uart_in_counter_inst.BAUD_TICK_COUNT                 = BAUD_TICK_COUNT,
         uart_in_counter_inst.HALF_BAUD_TICK_COUNT            = HALF_BAUD_TICK_COUNT,
         uart_in_counter_inst.TDW                             = TDW;
         
         
     fifo uart_in_fifo_inst(
                 .clk(clk),
                 .rst_n(rst_n),
                 .din(data_in_shift_reg[(DW + 1):1]),  // 写入fifo的是data_in_shift_reg读取的，要删掉起始位和结束位
                 .wr_en(all_bits_received & ~fifo_is_full), // 写入fifo的时机是接收完一个byte
                 .rd_en(receive_data_en & ~fifo_is_empty), // 读取fifo的时机是receive_data_en拉高
                 .dout(received_data), // received_data 传出数据
                 .full(fifo_is_full),
                 //.wr_ack(),
                 .empty(fifo_is_empty),
                 //.valid(),
                 .data_count(fifo_used)
      );
    
endmodule


```

进行一个简单的仿真

```verilog

module uart_in_deserializer_tb();
    reg             Clk;
    reg             Rst_n;
    
    reg             Serial_data_in;
    reg             Receive_data_en;
    wire            [10: 0]Fifo_read_available;
    wire            Received_data_valid;
    wire            [7:0]Received_data;
    
    uart_in_deserializer uart_in_deserializer_inst(
        // Inputs
        .clk(Clk),
        .rst_n(Rst_n),
        .serial_data_in(Serial_data_in),
        .receive_data_en(Receive_data_en),
        // Bidirectionals
        // Outputs
        .fifo_read_available(Fifo_read_available),
        .received_data_valid(Received_data_valid),
        .received_data(Received_data)
     );
     
     initial
     begin
                 Clk = 1;
                 Rst_n = 1;
                 Receive_data_en = 0;
                 Serial_data_in = 1;
                 
                 #10;
                 Rst_n = 0;
                 #10;
                 Rst_n = 1;
                 #10;
                 #4340;
                 Serial_data_in = 0; // 起始位
                 #4340;              // baudrate
                 Serial_data_in = 1; // 数据1 
                 #4340;              // baudrate
                 Serial_data_in = 1; // 数据2
                 #4340;              // baudrate
                 Serial_data_in = 0; // 数据3 
                 #4340;              // baudrate
                 Serial_data_in = 1; // 数据4 
                 #4340;              // baudrate
                 Serial_data_in = 0; // 数据5
                 #4340;              // baudrate
                 Serial_data_in = 0; // 数据6 
                 #4340;              // baudrate
                 Serial_data_in = 0; // 数据7 
                 #4340;              // baudrate
                 Serial_data_in = 0; // 数据8
                 #4340;              // baudrate
                 Serial_data_in = 1; // 结束位
                 #4340;              // baudrate
                 #4340;              // baudrate
                 Receive_data_en = 1;
                 #10;
                 Receive_data_en = 0;
                 #200000;
                 $stop;
     end
     
     always
     begin
                 #5;
                 Clk = ~Clk;
     end
    
endmodule


```


结果如下,在Serial_data_in 读入数据后,fifo会存储读入的数据,在Receive_data_en拉高后,读出一个数据.


![](https://pic.downk.cc/item/5ee34507c2a9a83be55bf024.jpg)
